<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="refresh" content="2">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>LC Shelf Order Viewer</title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #121a33;
      --card2: #0f1730;
      --text: #e6e8ef;
      --muted: #aab0c0;
      --ok: #2bd576;
      --bad: #ff5c5c;
      --warn: #ffcc66;
      --border: rgba(255,255,255,0.10);
      --shadow: 0 8px 30px rgba(0,0,0,0.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    body {
      margin: 0;
      background: radial-gradient(1200px 700px at 20% 10%, #1b2550 0%, var(--bg) 60%);
      color: var(--text);
      font-family: var(--sans);
    }
    .wrap { max-width: 1100px; margin: 28px auto; padding: 0 16px 60px; }
    header {
      display: flex; align-items: flex-end; justify-content: space-between; gap: 12px;
      margin-bottom: 14px;
    }
    h1 { margin: 0; font-size: 22px; letter-spacing: 0.2px; }
    .sub { color: var(--muted); font-size: 13px; margin-top: 4px; }
    .pill {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      padding: 6px 10px;
      border-radius: 999px;
    }
    .panel {
      background: rgba(18, 26, 51, 0.72);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      margin-top: 14px;
    }
    .rowTitle {
      display: flex; align-items: center; justify-content: space-between;
      margin: 6px 2px 10px;
    }
    .rowTitle h2 { margin: 0; font-size: 14px; color: var(--text); font-weight: 700; }
    .rowTitle .hint { font-size: 12px; color: var(--muted); }
    .shelf {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(150px, 1fr);
      gap: 10px;
      overflow-x: auto;
      padding-bottom: 8px;
    }
    .book {
      position: relative;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      padding: 10px 10px 9px;
      cursor: default;
      min-height: 70px;
    }
    .book.good { outline: 1px solid rgba(43,213,118,0.35); }
    .book.bad  { outline: 2px solid rgba(255,92,92,0.55); }
    .book.dup  { opacity: 0.4; outline: 1px dashed rgba(255,204,102,0.45); }
    .book .idx {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }
    .book .call {
      margin-top: 6px;
      font-family: var(--mono);
      font-size: 14px;
      line-height: 1.2;
      word-break: break-word;
    }
    .book .lc {
      margin-top: 6px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      opacity: 0.95;
      word-break: break-word;
    }
    .tag {
      position: absolute;
      top: 10px; right: 10px;
      font-family: var(--mono);
      font-size: 11px;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      color: var(--muted);
    }
    .tag.bad { color: #ffd0d0; border-color: rgba(255,92,92,0.55); }
    .tag.good { color: #c9ffe2; border-color: rgba(43,213,118,0.45); }
    .tag.dup { color: #ffe2b5; border-color: rgba(255,204,102,0.45); }

    /* tooltip */
    .tooltip {
      position: absolute;
      left: 10px;
      top: calc(100% + 8px);
      z-index: 50;
      width: 320px;
      max-width: calc(100vw - 70px);
      border-radius: 12px;
      background: rgba(10, 14, 28, 0.95);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 10px 10px 9px;
      display: none;
    }
    .book:hover .tooltip { display: block; }
    .tooltip .t { font-family: var(--mono); font-size: 11px; color: var(--muted); margin-bottom: 6px; }
    .kv { display: grid; grid-template-columns: 90px 1fr; gap: 6px 10px; }
    .k { font-family: var(--mono); font-size: 11px; color: var(--muted); }
    .v { font-family: var(--mono); font-size: 11px; color: var(--text); word-break: break-word; }

    .footer {
      margin-top: 16px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }
    .warnBox {
      margin-top: 12px;
      border: 1px solid rgba(255,204,102,0.35);
      background: rgba(255,204,102,0.08);
      border-radius: 12px;
      padding: 10px 12px;
      color: #ffe2b5;
      font-size: 12px;
    }
    .warnBox code { font-family: var(--mono); }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>LC Shelf Order Viewer</h1>
      <div class="sub">Auto-deduplicated • Current order vs LC-sorted order</div>
    </div>
    <div class="pill" id="meta">loading…</div>
  </header>

  <div class="panel">
    <div class="rowTitle">
      <h2>As scanned (left → right)</h2>
      <div class="hint">Red = out of place • Faded = duplicate</div>
    </div>
    <div class="shelf" id="rowCurrent"></div>
  </div>

  <div class="panel">
    <div class="rowTitle">
      <h2>Correct order (LC sorted, duplicates removed)</h2>
      <div class="hint">Only unique books, sorted by LC classification</div>
    </div>
    <div class="shelf" id="rowCorrect"></div>
    <div class="footer">
      Prefixes like <span style="font-family:var(--mono)">MATH PHYS</span> or <span style="font-family:var(--mono)">ENGR</span> are stripped.
      Duplicates are detected by comparing core LC call numbers (e.g., "TJ 211" matches "ENGR TJ 211").
    </div>
  </div>

  <div class="warnBox" id="warnBox" style="display:none;"></div>
</div>

<script>
/**
 * Extract LC portion from a raw OCR call-number-ish string.
 * Remove common prefix labels (ENGR, MATH, PHYS, etc.)
 */
function extractLC(raw) {
  if (!raw) return { lc: "", error: "empty" };
  const text = String(raw).trim().toUpperCase();
  const tokens = text.split(/\s+/).filter(Boolean);

  // Remove prefix words that aren't part of LC classification
  const prefixes = ['ENGR', 'MATH', 'PHYS', 'DNOIR', 'ENOR', 'FAGR', 'FNGR', 'SCI', 'TECH'];
  let cleaned = [...tokens];
  while (cleaned.length > 0 && prefixes.includes(cleaned[0])) {
    cleaned.shift();
  }

  // Find first token that is 1–3 letters AND next token starts with a digit
  let start = -1;
  for (let i = 0; i < cleaned.length - 1; i++) {
    const t0 = cleaned[i];
    const t1 = cleaned[i + 1];
    if (/^[A-Z]{1,3}$/.test(t0) && /^\d/.test(t1)) {
      start = i;
      break;
    }
  }
  
  if (start < 0) return { lc: "", error: "no CLASS+NUMBER pattern" };
  return { lc: cleaned.slice(start).join(" "), error: "" };
}

/**
 * Parse minimal LC components for sorting and deduplication
 */
function parseLC(lc) {
  const out = {
    valid: false,
    classLetters: "",
    classNumber: NaN,
    cutter: "",
    year: null,
    raw: lc,
    core: ""  // For deduplication: "CLASS NUMBER"
  };
  if (!lc) return out;

  let s = String(lc).trim().toUpperCase();

  // class letters
  const mClass = s.match(/^([A-Z]{1,3})\s+/);
  if (!mClass) return out;
  out.classLetters = mClass[1];
  s = s.slice(mClass[0].length).trim();

  // class number
  const mNum = s.match(/^(\d+)(?:\.(\d+))?/);
  if (!mNum) return out;
  const intPart = parseInt(mNum[1], 10);
  const decPart = mNum[2] ? mNum[2] : "";
  out.classNumber = intPart + (decPart ? parseFloat("0." + decPart) : 0.0);
  s = s.slice(mNum[0].length).trim();

  // Core for deduplication: just CLASS + NUMBER
  out.core = `${out.classLetters} ${mNum[0]}`;

  // cutter: accept "A123", ".A123", "A12B3", ".A12B3"
  const mCut = s.match(/(?:^|\s)(\.?[A-Z]\d+[A-Z]?\d*)(?:\s|$)/);
  if (mCut) {
    out.cutter = mCut[1].replace(/^\./, "");
    s = s.replace(mCut[1], " ").trim();
  }

  // year
  const mYear = s.match(/\b(19\d{2}|20\d{2})\b/);
  if (mYear) out.year = parseInt(mYear[1], 10);

  out.valid = true;
  return out;
}

/** Comparison function for sorting parsed LC objects */
function lcCompare(a, b) {
  if (!a.valid && !b.valid) return 0;
  if (!a.valid) return 1;
  if (!b.valid) return -1;

  if (a.classLetters !== b.classLetters) return a.classLetters < b.classLetters ? -1 : 1;

  const da = a.classNumber, db = b.classNumber;
  if (Math.abs(da - db) > 1e-6) return da < db ? -1 : 1;

  if (a.cutter !== b.cutter) return a.cutter < b.cutter ? -1 : 1;

  if (a.year !== b.year) {
    if (a.year == null) return -1;
    if (b.year == null) return 1;
    return a.year < b.year ? -1 : 1;
  }
  return 0;
}

/** Check if two books are duplicates based on core LC classification */
function areDuplicates(parsed1, parsed2) {
  if (!parsed1.valid || !parsed2.valid) return false;
  
  // Same core = duplicate (e.g., "TJ 211" == "TJ 211")
  return parsed1.core === parsed2.core;
}

/** Deduplicate books - keep first occurrence of each unique core */
function deduplicateBooks(books) {
  const unique = [];
  const seen = new Set();
  
  for (const book of books) {
    const core = book._parsed?.core || "";
    if (!core || !seen.has(core)) {
      unique.push(book);
      if (core) seen.add(core);
    } else {
      book._isDuplicate = true;
    }
  }
  
  return unique;
}

function el(tag, cls, html) {
  const e = document.createElement(tag);
  if (cls) e.className = cls;
  if (html != null) e.innerHTML = html;
  return e;
}

function renderRow(container, books, wrongSet, titleMode, showDuplicates = false) {
  container.innerHTML = "";
  
  const toRender = showDuplicates ? books : books.filter(b => !b._isDuplicate);
  
  toRender.forEach((b, idx) => {
    const key = b._key;
    const isWrong = wrongSet.has(key);
    const isDup = b._isDuplicate;

    let cardClass = "book ";
    if (isDup) cardClass += "dup";
    else if (isWrong) cardClass += "bad";
    else cardClass += "good";

    const card = el("div", cardClass);
    
    let tagText = "OK";
    let tagClass = "tag good";
    if (isDup) {
      tagText = "DUP";
      tagClass = "tag dup";
    } else if (isWrong) {
      tagText = "OUT";
      tagClass = "tag bad";
    }
    
    const tag = el("div", tagClass, tagText);
    card.appendChild(tag);

    const displayIdx = showDuplicates ? b._originalIndex : idx + 1;
    card.appendChild(el("div", "idx", `${displayIdx}. x=${b.x_position?.toFixed?.(1) ?? "?"}`));

    const mainText = titleMode === "raw" ? b.call_number : (b._lc || b.call_number);
    card.appendChild(el("div", "call", mainText));

    if (b._lc && titleMode === "raw") {
      card.appendChild(el("div", "lc", `LC: ${b._lc}`));
    }

    // tooltip
    const tip = el("div", "tooltip");
    tip.appendChild(el("div", "t", "Details"));
    const kv = el("div", "kv");
    const add = (k,v) => { kv.appendChild(el("div","k",k)); kv.appendChild(el("div","v",v)); };
    add("raw", b.call_number || "");
    add("lc", b._lc || "(not found)");
    add("core", b._parsed?.core || "(not found)");
    add("duplicate", isDup ? "yes" : "no");
    add("confidence", (b.confidence != null) ? String(b.confidence.toFixed ? b.confidence.toFixed(3) : b.confidence) : "(n/a)");
    add("x_position", (b.x_position != null) ? String(b.x_position.toFixed ? b.x_position.toFixed(2) : b.x_position) : "(n/a)");
    add("valid", b._parsed?.valid ? "true" : "false");
    add("class", b._parsed?.classLetters || "");
    add("number", (b._parsed?.classNumber != null && !Number.isNaN(b._parsed.classNumber)) ? String(b._parsed.classNumber) : "");
    add("cutter", b._parsed?.cutter || "");
    add("year", (b._parsed?.year != null) ? String(b._parsed.year) : "");
    tip.appendChild(kv);
    card.appendChild(tip);

    container.appendChild(card);
  });
}

async function main() {
  const meta = document.getElementById("meta");
  const warnBox = document.getElementById("warnBox");

  let data;
  try {
    data = await fetch("shelf_order.json").then(r => r.json());
  } catch (e) {
    meta.textContent = "failed to load shelf_order.json";
    warnBox.style.display = "block";
    warnBox.innerHTML =
      `Could not load <code>shelf_order.json</code>. Put it next to <code>viewer.html</code> and run:<br/>` +
      `<code>python3 -m http.server 8000</code>`;
    return;
  }

  const books = (data.books || []).map((b, i) => {
    const raw = b.call_number || "";
    const ex = extractLC(raw);
    const parsed = ex.lc ? parseLC(ex.lc) : { valid:false };

    return {
      ...b,
      _key: String(b.position ?? i),
      _originalIndex: i + 1,
      _lc: ex.lc,
      _lc_error: ex.error,
      _parsed: parsed,
      _isDuplicate: false
    };
  });

  // Mark duplicates
  for (let i = 0; i < books.length; i++) {
    if (books[i]._isDuplicate) continue;
    for (let j = i + 1; j < books.length; j++) {
      if (areDuplicates(books[i]._parsed, books[j]._parsed)) {
        books[j]._isDuplicate = true;
      }
    }
  }

  const uniqueBooks = books.filter(b => !b._isDuplicate);
  const duplicateCount = books.length - uniqueBooks.length;

  meta.textContent = `${data.image_file || "image"} • ${uniqueBooks.length} unique books` + 
                     (duplicateCount > 0 ? ` • ${duplicateCount} duplicates removed` : "");

  // Correct order: sort unique books only
  const correct = [...uniqueBooks].sort((A, B) => lcCompare(A._parsed, B._parsed));

  // Find which books are out-of-place
  const wrongSet = new Set();
  for (let i = 0; i < uniqueBooks.length; i++) {
    if (uniqueBooks[i]._key !== correct[i]?._key) {
      wrongSet.add(uniqueBooks[i]._key);
      if (correct[i]) wrongSet.add(correct[i]._key);
    }
  }

  // Show warning for duplicates
  if (duplicateCount > 0) {
    const dups = books.filter(b => b._isDuplicate);
    warnBox.style.display = "block";
    const examples = dups.slice(0, 3).map(b => 
      `<li><code>${b.call_number}</code> (core: ${b._parsed?.core || "?"})</li>`
    ).join("");
    warnBox.innerHTML =
      `<b>Info:</b> ${duplicateCount} duplicate(s) detected and hidden from correct order view.<br/>` +
      `Duplicates shown as faded in "As scanned" row:<ul>${examples}</ul>`;
  }

  // Warn if some books couldn't be parsed
  const invalid = uniqueBooks.filter(b => !b._parsed?.valid);
  if (invalid.length) {
    const examples = invalid.slice(0, 3).map(b => `<li><code>${b.call_number}</code></li>`).join("");
    const msg = `<br/><b>Warning:</b> ${invalid.length} book(s) did not match <code>CLASS + NUMBER</code>.<br/>` +
      `Examples:<ul>${examples}</ul>`;
    warnBox.style.display = "block";
    warnBox.innerHTML += msg;
  }

  renderRow(document.getElementById("rowCurrent"), books, wrongSet, "raw", true);
  renderRow(document.getElementById("rowCorrect"), correct, wrongSet, "lc", false);
}

main();
</script>
</body>
</html>