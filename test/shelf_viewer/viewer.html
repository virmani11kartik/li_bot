<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="refresh" content="2">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>LC Shelf Order Viewer</title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #121a33;
      --card2: #0f1730;
      --text: #e6e8ef;
      --muted: #aab0c0;
      --ok: #2bd576;
      --bad: #ff5c5c;
      --warn: #ffcc66;
      --border: rgba(255,255,255,0.10);
      --shadow: 0 8px 30px rgba(0,0,0,0.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    body {
      margin: 0;
      background: radial-gradient(1200px 700px at 20% 10%, #1b2550 0%, var(--bg) 60%);
      color: var(--text);
      font-family: var(--sans);
    }
    .wrap { max-width: 1100px; margin: 28px auto; padding: 0 16px 60px; }
    header {
      display: flex; align-items: flex-end; justify-content: space-between; gap: 12px;
      margin-bottom: 14px;
    }
    h1 { margin: 0; font-size: 22px; letter-spacing: 0.2px; }
    .sub { color: var(--muted); font-size: 13px; margin-top: 4px; }
    .pill {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      padding: 6px 10px;
      border-radius: 999px;
    }
    .panel {
      background: rgba(18, 26, 51, 0.72);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      margin-top: 14px;
    }
    .rowTitle {
      display: flex; align-items: center; justify-content: space-between;
      margin: 6px 2px 10px;
    }
    .rowTitle h2 { margin: 0; font-size: 14px; color: var(--text); font-weight: 700; }
    .rowTitle .hint { font-size: 12px; color: var(--muted); }
    .shelf {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(150px, 1fr);
      gap: 10px;
      overflow-x: auto;
      padding-bottom: 8px;
    }
    .book {
      position: relative;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      padding: 10px 10px 9px;
      cursor: default;
      min-height: 70px;
    }
    .book.good { outline: 1px solid rgba(43,213,118,0.35); }
    .book.bad  { outline: 2px solid rgba(255,92,92,0.55); }
    .book .idx {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }
    .book .call {
      margin-top: 6px;
      font-family: var(--mono);
      font-size: 14px;
      line-height: 1.2;
      word-break: break-word;
    }
    .book .lc {
      margin-top: 6px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      opacity: 0.95;
      word-break: break-word;
    }
    .tag {
      position: absolute;
      top: 10px; right: 10px;
      font-family: var(--mono);
      font-size: 11px;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      color: var(--muted);
    }
    .tag.bad { color: #ffd0d0; border-color: rgba(255,92,92,0.55); }
    .tag.good { color: #c9ffe2; border-color: rgba(43,213,118,0.45); }

    /* tooltip */
    .tooltip {
      position: absolute;
      left: 10px;
      top: calc(100% + 8px);
      z-index: 50;
      width: 320px;
      max-width: calc(100vw - 70px);
      border-radius: 12px;
      background: rgba(10, 14, 28, 0.95);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 10px 10px 9px;
      display: none;
    }
    .book:hover .tooltip { display: block; }
    .tooltip .t { font-family: var(--mono); font-size: 11px; color: var(--muted); margin-bottom: 6px; }
    .kv { display: grid; grid-template-columns: 90px 1fr; gap: 6px 10px; }
    .k { font-family: var(--mono); font-size: 11px; color: var(--muted); }
    .v { font-family: var(--mono); font-size: 11px; color: var(--text); word-break: break-word; }

    .footer {
      margin-top: 16px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }
    .warnBox {
      margin-top: 12px;
      border: 1px solid rgba(255,204,102,0.35);
      background: rgba(255,204,102,0.08);
      border-radius: 12px;
      padding: 10px 12px;
      color: #ffe2b5;
      font-size: 12px;
    }
    .warnBox code { font-family: var(--mono); }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>LC Shelf Order Viewer</h1>
      <div class="sub">Static visual check: current order vs LC-sorted order.</div>
    </div>
    <div class="pill" id="meta">loading…</div>
  </header>

  <div class="panel">
    <div class="rowTitle">
      <h2>As scanned (left → right)</h2>
      <div class="hint">Red = out of place vs LC order</div>
    </div>
    <div class="shelf" id="rowCurrent"></div>
  </div>

  <div class="panel">
    <div class="rowTitle">
      <h2>Correct order (LC sorted)</h2>
      <div class="hint">Derived from the same scan data (prefix labels ignored)</div>
    </div>
    <div class="shelf" id="rowCorrect"></div>
    <div class="footer">
      Prefixes like <span style="font-family:var(--mono)">MATH PHYS</span> or <span style="font-family:var(--mono)">ENGR</span>,
      this viewer extracts the LC call number by locating the first <span style="font-family:var(--mono)">CLASS + NUMBER</span> pattern.
    </div>
  </div>

  <div class="warnBox" id="warnBox" style="display:none;"></div>
</div>

<script>
/**
 * Extract LC portion from a raw OCR call-number-ish string.
 * Rule: find first token that is 1–3 letters AND next token starts with a digit.
 * This skips department labels like MATH/PHYS/ENGR.
 */
function extractLC(raw) {
  if (!raw) return { lc: "", error: "empty" };
  const text = String(raw).trim().toUpperCase();
  const tokens = text.split(/\s+/).filter(Boolean);

  let start = -1;
  for (let i = 0; i < tokens.length - 1; i++) {
    const t0 = tokens[i];
    const t1 = tokens[i + 1];
    if (/^[A-Z]{1,3}$/.test(t0) && /^\d/.test(t1)) {
      start = i;
      break;
    }
  }
  if (start < 0) return { lc: "", error: "no CLASS+NUMBER pattern" };
  return { lc: tokens.slice(start).join(" "), error: "" };
}

/**
 * Parse minimal LC components for sorting:
 * - class letters: 1–3 letters
 * - class number: numeric (supports decimals)
 * - cutter: first token like A123 / .A123 / A12B3 (we accept common OCR variations)
 * - year: 19xx or 20xx
 */
function parseLC(lc) {
  const out = {
    valid: false,
    classLetters: "",
    classNumber: NaN,
    cutter: "",
    year: null,
    raw: lc
  };
  if (!lc) return out;

  let s = String(lc).trim().toUpperCase();

  // class letters
  const mClass = s.match(/^([A-Z]{1,3})\s+/);
  if (!mClass) return out;
  out.classLetters = mClass[1];
  s = s.slice(mClass[0].length).trim();

  // class number
  const mNum = s.match(/^(\d+)(?:\.(\d+))?/);
  if (!mNum) return out;
  const intPart = parseInt(mNum[1], 10);
  const decPart = mNum[2] ? mNum[2] : "";
  out.classNumber = intPart + (decPart ? parseFloat("0." + decPart) : 0.0);
  s = s.slice(mNum[0].length).trim();

  // cutter: accept "A123", ".A123", "A12B3", ".A12B3"
  // We'll take the first thing that matches.
  const mCut = s.match(/(?:^|\s)(\.?[A-Z]\d+[A-Z]?\d*)(?:\s|$)/);
  if (mCut) {
    out.cutter = mCut[1].replace(/^\./, ""); // normalize
    s = s.replace(mCut[1], " ").trim();
  }

  // year
  const mYear = s.match(/\b(19\d{2}|20\d{2})\b/);
  if (mYear) out.year = parseInt(mYear[1], 10);

  out.valid = true;
  return out;
}

/** Comparison function for sorting parsed LC objects */
function lcCompare(a, b) {
  // invalids go last
  if (!a.valid && !b.valid) return 0;
  if (!a.valid) return 1;
  if (!b.valid) return -1;

  if (a.classLetters !== b.classLetters) return a.classLetters < b.classLetters ? -1 : 1;

  const da = a.classNumber, db = b.classNumber;
  if (Math.abs(da - db) > 1e-6) return da < db ? -1 : 1;

  if (a.cutter !== b.cutter) return a.cutter < b.cutter ? -1 : 1;

  if (a.year !== b.year) {
    if (a.year == null) return -1;
    if (b.year == null) return 1;
    return a.year < b.year ? -1 : 1;
  }
  return 0;
}

function el(tag, cls, html) {
  const e = document.createElement(tag);
  if (cls) e.className = cls;
  if (html != null) e.innerHTML = html;
  return e;
}

function renderRow(container, books, wrongSet, titleMode) {
  container.innerHTML = "";
  books.forEach((b, idx) => {
    const key = b._key;
    const isWrong = wrongSet.has(key);

    const card = el("div", "book " + (isWrong ? "bad" : "good"));
    const tag = el("div", "tag " + (isWrong ? "bad" : "good"), isWrong ? "OUT" : "OK");
    card.appendChild(tag);

    card.appendChild(el("div", "idx", `${idx+1}. x=${b.x_position?.toFixed?.(1) ?? "?"}`));

    // Display line: raw or LC depending on row
    const mainText = titleMode === "raw" ? b.call_number : (b._lc || b.call_number);
    card.appendChild(el("div", "call", mainText));

    if (b._lc && titleMode === "raw") {
      card.appendChild(el("div", "lc", `LC: ${b._lc}`));
    }

    // tooltip
    const tip = el("div", "tooltip");
    tip.appendChild(el("div", "t", "Details"));
    const kv = el("div", "kv");
    const add = (k,v) => { kv.appendChild(el("div","k",k)); kv.appendChild(el("div","v",v)); };
    add("raw", b.call_number || "");
    add("lc", b._lc || "(not found)");
    add("confidence", (b.confidence != null) ? String(b.confidence.toFixed ? b.confidence.toFixed(3) : b.confidence) : "(n/a)");
    add("x_position", (b.x_position != null) ? String(b.x_position.toFixed ? b.x_position.toFixed(2) : b.x_position) : "(n/a)");
    add("valid", b._parsed?.valid ? "true" : "false");
    add("class", b._parsed?.classLetters || "");
    add("number", (b._parsed?.classNumber != null && !Number.isNaN(b._parsed.classNumber)) ? String(b._parsed.classNumber) : "");
    add("cutter", b._parsed?.cutter || "");
    add("year", (b._parsed?.year != null) ? String(b._parsed.year) : "");
    tip.appendChild(kv);
    card.appendChild(tip);

    container.appendChild(card);
  });
}

async function main() {
  const meta = document.getElementById("meta");
  const warnBox = document.getElementById("warnBox");

  let data;
  try {
    data = await fetch("shelf_order.json").then(r => r.json());
  } catch (e) {
    meta.textContent = "failed to load shelf_order.json";
    warnBox.style.display = "block";
    warnBox.innerHTML =
      `Could not load <code>shelf_order.json</code>. Put it next to <code>viewer.html</code> and run:<br/>` +
      `<code>python3 -m http.server 8000</code>`;
    return;
  }

  const books = (data.books || []).map((b, i) => {
    const raw = b.call_number || "";
    const ex = extractLC(raw);
    const parsed = ex.lc ? parseLC(ex.lc) : { valid:false };

    return {
      ...b,
      _key: String(b.position ?? i),     // stable ID for mismatch checks
      _lc: ex.lc,
      _lc_error: ex.error,
      _parsed: parsed
    };
  });

  meta.textContent = `${data.image_file || "image"} • ${books.length} books`;

  // Correct order: sort by parsed LC (invalids go last)
  const correct = [...books].sort((A, B) => lcCompare(A._parsed, B._parsed));

  // Find which books are out-of-place by comparing expected sequence
  const wrongSet = new Set();
  for (let i = 0; i < books.length; i++) {
    if (books[i]._key !== correct[i]?._key) {
      wrongSet.add(books[i]._key);
      if (correct[i]) wrongSet.add(correct[i]._key);
    }
  }

  // Warn if some books couldn't be parsed into LC
  const invalid = books.filter(b => !b._parsed?.valid);
  if (invalid.length) {
    warnBox.style.display = "block";
    const examples = invalid.slice(0, 4).map(b => `<li><code>${b.call_number}</code></li>`).join("");
    warnBox.innerHTML =
      `<b>Warning:</b> ${invalid.length} book(s) did not match <code>CLASS + NUMBER</code> and will sort last.<br/>` +
      `Examples:<ul>${examples}</ul>` +
      `If these are department labels, make sure the LC class + number is present somewhere in the OCR output.`;
  }

  renderRow(document.getElementById("rowCurrent"), books, wrongSet, "raw");
  renderRow(document.getElementById("rowCorrect"), correct, wrongSet, "lc");
}

main();
</script>
</body>
</html>
